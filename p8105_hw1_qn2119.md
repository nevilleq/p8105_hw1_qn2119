P8105 Homework 1
================
Quinton Neville
September 17, 2018

Problem 1
=========

First, we will create a data frame `variable.types.df`, containing a random sample variable from a random variable *X* ∼ *U**n**i**f**o**r**m*(0, 5), a logical variable describing whether those elements are greater than two, and a character variable from a random sample from *Y* = \[Zero, One, Two\], and a coerced factor variable of the previous variable.

``` r
#Defining number of rows/observations for our variable types data frame
n.row.types.df <- 10

#Set the seed for reproducibility in random sample
set.seed(24)

#Generate a character sample using strsplit on a generic sample, need unlist to coerce to vector
char.sentence <- "The quick brown fox jumped over the lazy dog"  
char.word.sample <- unlist(strsplit(char.sentence, "[ ]"))

#Creating our data frame with rUnif(0,5), logical, character random sample, and factor vars
variable.types.df <- tibble(
  unif.sample = runif(n.row.types.df, min = 0, max = 5),                  #Random sample 10 rUnif(0,5)
  logical.unif.g.2 = ifelse(unif.sample > 2, TRUE, FALSE),                #Logical, TRUE if rUnif > 2
  char.sample = sample(char.word.sample, n.row.types.df, replace = TRUE), #Random char sample
  factor.char.sample = as.factor(sample(1:5, n.row.types.df, replace = TRUE))   #Random factor sample, 5 levels
)
```

Now, we will attempt to take the mean of each variable in `variable.types.df`.

``` r
#Here we use the apply function to apply the mean function to each column var
mean.variable.types <- apply(variable.types.df, 2, mean)

#Apply gives all NA's because last 2 cols are non-numeric, so will go individually instead
mean.variable.types <- with(variable.types.df, c(mean(unif.sample),
                                               mean(logical.unif.g.2),
                                               mean(char.sample),
                                               mean(factor.char.sample)))
names(mean.variable.types) <- colnames(variable.types.df)
mean.variable.types
```

    ##        unif.sample   logical.unif.g.2        char.sample 
    ##            2.71178            0.60000                 NA 
    ## factor.char.sample 
    ##                 NA

We see that the `mean()` function works for the Uniform sample variable because it is of numeric data type, and surprisingly also works for the logical variable describing whether each value in the sample is greater than two. This occurs because when `mean()` encounters a logical data type, it automatically converts it using `as.numeric()` to 1's and 0's, thus giving us the numeric proportion of `TRUE` for the logical variable. As for the character and factor variables, the `mean()` function does not work because these data types are non-numeric, and returns `NA` instead.

Now we will convert the logical, character, and factor variables in `variable.types.df`to numeric data types.

``` r
#Using the mutate function in dplyr, we will create a new df with coerced numerics
coerced.numeric.df <- variable.types.df %>%
  mutate(numeric.logical.g.2 = as.numeric(logical.unif.g.2),
         numeric.char.sample = as.numeric(char.sample),
         numeric.factor.sample = as.numeric(factor.char.sample))

#Check out the new variables
head(coerced.numeric.df[,5:7])
```

When we attempt to coerce the logical, character, and factor data types, respectively, we see that the logical is transformed from `TRUE` and `FALSE` to 1's and 0's, the character cannot be coerced to numeric and produces `NA`'s, while the factor variable is converted to a numeric describing which level in which the factor object resides. However, it is important to note that if a character variable took the form `c("1", "2", etc.), it would be coerced to the corresponding integer by`as.numeric()\`.

Lastly, we will coerce the original character variable to factor to numeric and the original factor variable to character to numeric.

``` r
#Creating a new data frame with variables for the aforementioned data type coercions
coerced.factor.char.df <- variable.types.df %>%
  mutate(char.coerced.factor.numeric = char.sample %>% as.factor %>% as.numeric,
         factor.coerced.char.numeric = factor.char.sample %>% as.character %>% as.numeric)

#Check out the new variables
head(coerced.factor.char.df[,5:6])
```

    ## # A tibble: 6 x 2
    ##   char.coerced.factor.numeric factor.coerced.char.numeric
    ##                         <dbl>                       <dbl>
    ## 1                           5                           1
    ## 2                           3                           3
    ## 3                           7                           4
    ## 4                           7                           1
    ## 5                           1                           2
    ## 6                           2                           4

Again, we see that coercing the character variable to a factor and then numeric, transforms the character variable to a factor with 8 levels, then to a numeric describing the corresponding levels in which the corresponding factor resides. On the other hand, because our original factor variable was "numeric", in the sense that it had 5 levels, described 1-5, when we coerce this variable to a character, it looks like `c("1", "3", etc.)`. So when we then coerce it to numeric, it assumes the integer values described by the characters. If, however, the factor levels had been ordinal rather than numeric, the end result would have been `NA` as true character variables cannot be coerced to numeric, as we saw earlier.

Problem 2
=========
